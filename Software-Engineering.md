# 软件工程

## 第一部分 软件工程概念

## 第二部分 软件过程工作流

对软件过程的定义有多种，这里主要参考 Stephen R. Schach 在《软件工程 面向对象和传统的方法》中描述的“软件生命周期的工作流”，包括以下流程：

+ 需求
+ 分析
+ 设计
+ 实现
+ 测试
+ 交付后维护

以及 Roger S. Pressman 和 Bruce R. Maxim 合著的《软件工程 实践者的研究方法》中描述的“软件过程框架活动”，包括：

+ 沟通
+ 策划
+ 建模
+ 构建
+ 部署

最后将软件过程描述为一系列工作流，包括：

1. 需求
2. 分析
3. 设计
4. 实现
5. 测试
6. 运维

### 2.1 需求

常用的软件过程范型基本上可以分为文档驱动、原型驱动和用例驱动。在面向对象范型中，软件过程主要由用例驱动。在对问题进行定以后，软件工程师就需要根据场景编写用例。

#### 问题定义

需求工作流始于**问题定义**。对问题的定义需要是清晰、明确、抽象的，软件问题定义的阅读者不只是软件小组成员，还应包括软件用户。问题定义应该较为简洁的描述“**做什么**”，而不涉及“怎么做”。

> 该阶段应产出一份清晰的问题定义说明。

#### 可行性分析

**可行性分析**的**目的**在于“用最小的代价在最短的时间内确定问题是否能够和值得解决”。可行性分析往往需要先确认并询问人员、查阅分析相关资料、改正含糊的概念，确保提出的问题确实是所要解决的问题后，进行四个方面的分析：

1. 策略可行性：问题是否有解决策略，暂时不考虑技术实现问题，如果没有解决问题的策略，则软件不可行；
2. 技术可行性：存在的策略需要在技术上予以实现，如果无法实现，则软件不可行；
3. 操作可行性：软件对于用户需要是可操作的，如果技术实现的接口让用户难以使用，则软件不可行；
4. 经济可行性：通过成本-效益分析法或其他方法，如果软件成本超过软件收益（包括潜在收益），则软件不可行。

> 该阶段应产出各种方面的可行性分析报告。

#### 基于数据流的需求工作流

传统的结构化方法重视数据和处理数据的过程（函数），是一种**面向数据**的方法。基于数据流的需求工作要经过以下步骤：

1. 提取和细化需求（<a href="#3-1">规格说明文档</a>）
2. 对系统流程建模（<a href="#3-2">流程图</a>）
3. 对数据流建模（<a href="#3-5">数据流图</a>）
4. 建立<a href="#3-3">数据字典</a>
5. 建立实体关系描述（<a href="#3-4">E - R 图</a>）
6. 建立系统状态转换描述（<a href="#4-5">状态图</a>）

从数据、功能、行为方面描述：

+ **数据建模**：数据字典、E - R 图
+ **功能建模**：数据流图
+ **行为建模**：状态转换图

从静态建模和动态建模方面描述：

+ **静态建模**：数据流图、数据字典、E - R 图
+ **动态建模**：状态转换图

> 如果使用基于数据流的需求工作流，该阶段需要产出规格说明文档、流程图、数据流图、数据字典、E - R 图和状态图。

#### 基于用例的需求工作流

统一过程和其他面向对象范型下的软件过程几乎都是由**用例（use case）**驱动的。用例即软件的功能使用场景，是一种基于**场景**、**面向对象**的建模方法。基于用例的需求工作流需要经过以下步骤：

1. 提取和细化需求（<a href="#3-1">规格说明文档</a>）
2. 开发用例（<a href="#4-1">UML 用例图</a>）
3. 细化用例（<a href="#3-6">用例规格说明</a>）
4. 进一步细化用例（<a href="#4-3">UML 交互图</a>和<a href="#4-4"> UML 活动图</a>）

一些软件工程方法将与类建模相关的工作划分在分析工作流中，另一些则认为类建模属于需求工程。如果认为类建模属于需求工作流，还有包括有以下步骤（在<a href="#2-2">2.2 节</a>说明）：

5. 抽取实体类（<a href="#4-2">UML 类图</a>）
6. 分析系统状态（<a href="#4-5">UML 状态图</a>）

从数据、功能、行为方面描述：

+ **数据建模**：UML 类图
+ **功能建模**：UML 用例图、用例规格说明
+ **行为建模**：UML 交互图、UML 活动图、UML 状态图

> UML 标准中将数据建模称为结构建模，将功能和行为建模统称为行为建模，此外还有体系结构（架构）建模。

从静态建模和动态建模方面描述：

+ **静态建模**：UML 类图、UML 用例图、用例规格说明
+ **动态建模**：UML 交互图、UML 活动图、UML 状态图

> 如果使用基于用例的需求工作流，该阶段需要产出UML 类图、UML 用例图、用例规格说明、UML 交互图、UML 活动图和UML 状态图，其中交互图和活动图是对用例的补充说明。

### 2.2 <span id="2-2">分析</span>

在分析流中，需要解决的问题仍是“**做什么**”，而不是“怎么做”，但是对过程的描述将比问题定义更加详细。

#### 安排工期

大部分软件项目开发都需要多人团队的参与。和工作流模型一样，各个团队成员的工作进程也是并行相交的。为了能够直观的表示各个成员的工作计划安排与当前进度情况，需要使用一种能够描述并行工作流的建模技术。<a href="#3-7">**甘特图**</a>是一种常用于制作工期安排文档的技术。

> 该阶段产出工期安排文档，供所有团队成员参考，管理者和用户也可以根据该文档进行项目评估。

#### 抽取实体类

抽取实体类包括三个步骤：

1. 对规格说明文档进行语法分析：TODO；
2. 描述类的属性：TODO；
3. 描述类的操作：TODO；

#### 修订实体类

#### 抽取边界类

#### 抽取控制类

### 2.3 设计

### 2.4 实现

### 2.5 测试

### 2.6 运维

## 第三部分 常用建模语言

第三部分介绍一些结构化程序设计和之外的常用建模语言，一些语言本身没有标准，但在实践中基本使用相似的符号。符号图片主要来自 [Microsoft Visio](https://www.microsoft.com/en-us/microsoft-365/visio/flowchart-software) 。

### <span id="3-1">3.1 规格说明文档</span>

#### 介绍

在软件工程中，**软件需求规格说明（Software Requirement Specification，SRS）**文档时在项目商业化前必须建立的详细描述软件各个方面的工作产品。一般必须包括有以下几个部分：

+ 文档概要：主要包括文档目的、问题定义、阅读人员、规范等引述性内容；
+ 软件描述：描述软件本身，包括软件特性、用户文档等部分；
+ 需求分析：详细分析需求，该部分内容将作为之后所有工作流的主要参考，一般包括功能性需求和非功能性需求部分。

> SRS 文档一般需要同时供项目成员和用户参考，如果认为 SRS 的内容性质过于而影响交流效率，也可以生成多份内容侧重和表现形式不同 SRS 文档。

#### 实例

下面是一份源自 Process Impact 公司的 Karl Wiegers 制作的 [SRS 模板](https://www.processimpact.com/process_assets/srs_template.doc)修改版，以供参考：

+ 目录
+ 版本历史
  + 修订人
  + 修订日期
  + 修订内容
+ 正文
  1. 导言
     1. 文档目的：描述文档的作用
     2. 软件目的：即问题定义
     3. 文档规范：文档格式约定等
     4. 适用人群和阅读建议
     5. 项目范围：该部分也可放在问题定义中
     6. 参考文献
  2. 总体描述
     1. 产品愿景：简洁描述软件是什么和能做什么
     2. 产品特性
     3. 用户类型和特征：推荐使用用户画像
     4. 操作环境：用户的使用环境
     5. 设计和实施约束
     6. 用户文档：该部分如果比较复杂也可独立于 SRS，作用类似于说明书手册
     7. 假设和依赖
  3. 系统特性
     1. 软件类型
     2. 软件运行环境
     3. 软件领域需求：如版权、领域规范、行业标准等
  4. 外部接口需求：以接口提供的服务描述功能性需求
     1. 用户接口：用户通过用户接口来使用软件的功能，该部分既要描述应该实现什么功能，也要描述用户如何使用这些功能
     2. 硬件接口
     3. 软件接口
     4. 通信接口
  5. 非功能性需求
     1. 性能需求
     2. 安全需求
     3. 保密需求
     4. 软件质量保证
  6. 其他需求
+ 术语表
+ 分析模型：通常是过程流中产生的各类模型
+ 问题列表：如果有遗留问题在此处记录以查阅和修正

### <span id="3-2">3.2 流程图</span>

#### 介绍

**流程图（flow chart）**是用于描述系统流程的工具，通常包含一组符号和文字说明。

流程图本身没有统一的规范，通常流程图包含以下符号：

| 符号                                                         | 含义                                             |
| ------------------------------------------------------------ | ------------------------------------------------ |
| ![流](.Software-Engineering-assets/image-20220331160619075.png) | 链接各个符号。                                   |
| ![流程](.Software-Engineering-assets/image-20220331160244829.png) | 流程的名字，如“用户登录”、“查询订单”等流程活动。 |
| ![判断](.Software-Engineering-assets/image-20220331160403722.png) | 条件分支，成功或失败等。                         |
| ![开始或结束](.Software-Engineering-assets/image-20220331160655390.png) | 流程图的开始和结束，必须成对出现。               |
| ![数据](.Software-Engineering-assets/image-20220331160748856.png) | 数据输入和输出，一般会链接文档或数据库。         |
| ![文档](.Software-Engineering-assets/image-20220331160808628.png) | 表示流程中会产生或读取纸质文档。                 |
| ![数据库](.Software-Engineering-assets/image-20220331160827435.png) | 表示流程中涉及的外部数据库。                     |
| ![引用](.Software-Engineering-assets/image-20220331160904752.png) | 表示链接到同一页的另外一块流程图。               |
| ![引用](.Software-Engineering-assets/image-20220331160923536.png) | 表示链接到另一页的另外一块流程图。               |

> 流程图属于静态模型，用于数据建模。

#### 实例

下面是一个用户发票的例子：

![flow-chart](.Software-Engineering-assets/flow-chart.png)

### <span id="3-3">3.3 数据字典</span>

#### 介绍

**数据字典（Data dictionary）**是一种用户可以访问的记录数据库和应用程序元数据的目录。数据字典主要记录关于数据的定义，而不关心数据间的相互关系。一般数据字典必须包括以下项：

+ 字段名
+ 数据类型：数据类型内容根据字典使用场景决定，如果是比较抽象的数据字典，类型只需包含一些元数据类型；如果数据字典就是面向特定系统的，则数据类型应该是系统中的类型；
+ 长度
+ 默认值
+ 可空
+ 备注

> 数据字典属于静态模型，用于数据建模。

#### 实例

下面是一个销售订单的数据字典，数据类型使用抽象类型，但注释中包含一些技术细节：

| 字段名           | 类型    | 长度 | 可空 | 默认值 | 注释                                         |
| ---------------- | ------- | ---- | ---- | ------ | -------------------------------------------- |
| trade_id         | String  | 25   |      |        | 自动生成，日期（8）+ `uuid_short()`（17）    |
| trade_status     | String  |      |      |        | `"已完成" `\|\| `"已取消"` \|\| `"等待处理"` |
| trade_start_time | String  |      |      |        | 交易发起时间，`timestamp`                    |
| trade_paid_time  | String  |      | 是   |        | 交易完成时间，`timestamp`                    |
| trade_price      | Float   |      | 是   |        | 交易价格                                     |
| trade_payment    | String  |      |      |        | 付款方式                                     |
| trade_signed     | Boolean |      |      |        | 产品是否已经签收                             |

### <span id="3-4">3.4 实体关系图</span>

#### 介绍

**实体-联系图(Entity Relationship Diagram，E-R)**，提供了表示实体类型、属性和联系的方法，是用来描述现实世界的概念模型。E-R 图被大量使用在关系型数据库的概念设计阶段中，注重数据间的相互联系。

E-R 图包含以下符号：

| 符号                                                         | 含义                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image-20220331163131684](.Software-Engineering-assets/image-20220331163131684.png) | 表示现实中的事物，如“人”、“商品”。                           |
| ![image-20220331163202208](.Software-Engineering-assets/image-20220331163202208.png) | 属性必须连接到实体上。                                       |
| ![image-20220331163226544](.Software-Engineering-assets/image-20220331163226544.png) | 关系描述不同实体间的联系，如“人购买商品”，“购买”就是关系。   |
| ![image-20220331163304454](.Software-Engineering-assets/image-20220331163304454.png) | 连接各个符号，对于实体和实体，可以表示一对一（1 : 1）、一对多（1 : N）和多对多关系（M : N）。 |

> E-R 图属于静态模型，用于数据建模。

#### 实例

下面是一个用户与产品、产品订单的 E-R 图例子：

![E-R](.Software-Engineering-assets/E-R.png)

### <span id="3-5">3.5 数据流图</span>

#### 介绍

**数据流图（Data Flow Diagram，DFD）**从数据传递和加工角度，以图形方式来表达系统的逻辑功能、数据在系统内部的逻辑流向和逻辑变换过程，是结构化系统分析方法的主要表达工具及用于表示软件模型的一种图示方法。

> 数据流通常使用分层方式绘制，即先进行总体建模，再进行局部细化。顶层数据流图被称为“0 层数据流图”，在顶层中通常不会描述数据存储过程。
>
> 每条数据流都应该遵循输入输出平衡原则，即输入和输出必须是成对的，否则数据流没有意义。

数据流图包含以下符号：

| 符号                                                         | 含义                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image-20220331160619075](.Software-Engineering-assets/image-20220331160619075.png) | 即数据流，数据流应该使用名词描述，表示某项数据。             |
| ![image-20220331164736943](.Software-Engineering-assets/image-20220331164736943.png) | 也称加工过程，表示系统的一个数据处理动作。                   |
| ![image-20220331164914996](.Software-Engineering-assets/image-20220331164914996.png) | 外部交互方一般是数据起点和终点，如“人”、“数据库”。           |
| <img src=".Software-Engineering-assets/image-20220331165815447.png" alt="image-20220331165815447" style="zoom:50%;" />或![image-20220331164955155](.Software-Engineering-assets/image-20220331164955155.png) | 数据存储必须连接到数据流程上，表示从存储中读取或向存储中存入数据。 |

如果单个流程和多条流相关，必须遵循以下原则：

![数据流图原则](.Software-Engineering-assets/image-20220331165519751.png)

> 数据流图属于静态模型，用于功能建模。

#### 实例

下面是一个餐厅管理系统的 1 层数据流图：

![餐厅管理系统](.Software-Engineering-assets/image-20220331170042900.png)

### <span id="3-6">3.6 用例规格说明</span>

#### 介绍

**用例规格说明（Use Case Requirement Specification）**是对用例内容的详细说明，一般会采用表格或列表的形式描述。根据实践经验总结，用例规格说明的内容通常应该包括以下内容：

| 项                 | 含义                                                   |
| ------------------ | ------------------------------------------------------ |
| 用例               | 用例的名字                                             |
| 主要参与者         | 用例的主要参与者，即使用者                             |
| 目标               | 描述用例对应的功能                                     |
| 前提条件           | 激活该用例必须满足的条件                               |
| 后置条件（触发器） | 用例结束后会发生的事情，也可以表述为激活某一个用例     |
| 主事件流（场景）   | 正常情况下会发生的事件流                               |
| 次事件流（异常）   | 用例中可能发生的异常以及其处理事件流                   |
| 优先级             | 描述功能优先级，可以表述为是否必须实现、在什么阶段实现 |
| 何时可用           | 功能再什么时候可用，可以表述为在某个版本中实现         |
| 使用频率           | 用例单位时间被激活的频率                               |
| 使用方式           | 主要参与者使用用例中功能的方式，如接口、软件           |
| 次要参与者         | 用例中的其他参与者                                     |
| 次要参与者使用方式 | 次要参与参与用例功能协作的方式                         |
| 未解决的问题       | 如果用例尚未完成，将问题记录以备查阅                   |

> 用例规格说明属于静态模型，用于需求建模，是对用例的具体描述或补充。

#### 实例

下面是一个市民登录 Web 站点以报告路面坑洼和严重程度的用例规格说明：

| 用例               | 登录 Web 站点                                                |
| ------------------ | ------------------------------------------------------------ |
| 参与者             | 市民                                                         |
| 目的               | 在报告前进行身份验证，防止恶意报告行为影响正常功能           |
| 前置条件           | 市民拥有能够访问 Web 的设备                                  |
| 后置条件           | 市民获得提交报告的权限                                       |
| 主事件流           | 1. 市民：打开客户端输入网址<br>2. 客户端：显示登录页面<br>3. 市民：输入账号密码<br>4. 客户端：发出请求<br>5. 服务器：响应验证<br>6. 客户端：允许用户进入 |
| 次事件流           | 1. 服务器错误：服务器无法处理页面请求<br>2. 客户端错误：客户端没有解析页面的能力，提示用户<br>3. 市民密码输入错误：必须重新输入直到正确 |
| 优先级             | 必须实现                                                     |
| 何时可用           | 首个版本                                                     |
| 使用频率           | 预计为较低的月频                                             |
| 使用方式           | 通过客户端浏览器                                             |
| 次要参与者         | 客户端，服务器                                               |
| 次要参与者使用方式 | 客户端和服务器：HTTP                                         |

### <span id="3-7">3.7 甘特图</span>

#### 介绍

**甘特图（Gantt chart）**也称横道图或条状图（Bar chart），由亨利·劳伦斯·甘特（Henry Laurence Gantt）提出。甘特图通过条状图来显示项目、进度和其他时间相关的系统进展的内在关系随着时间进展的情况。

甘特图一般必须包括以下信息：

+ 任务
+ 时间
+ 任务预期安排
+ 当前任务进度

复杂的甘特图还可以添加其他辅助信息，如：

+ 任务简介
+ 参与人员
+ 统计信息
+ 注释
+ ......

#### 实例

下方是一个最简单的甘特图实例：

![简单甘特图](.Software-Engineering-assets/simple-gantt.png)

## 第四部分 统一建模语言

> 第四部分参考 *The Unified Modeling Language User Guide*（《UML 用户指南》），Grady Booch，James Rumbaugh，Ivar Jacobson 著，邵维忠 等译。
>
> [UML 官方网站](http://uml.org)
>
> 据 [Wikipedia](https://en.wikipedia.org/wiki/Unified_Modeling_Language)：**统一建模语言**（英语：Unified Modeling Language，缩写 **UML**）是非专利的第三代建模和规约语言。UML 是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。UML 展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层次已经被验证有效。
>
> 这个语言由葛来迪·布区（Grady Booch），伊瓦尔·雅各布森（Ivar Jacobson）与詹姆士·兰宝（James Rumbaugh）于 1994 年至 1995 年间，在 Rational Software 公司中开发，于 1996年 又进一步发展。UML 集成了 Booch ，对象建模技术和面向对象程序设计的概念，将这些方法融合为单一的，通用的，并且可以广泛使用的建模语言。UML 打算成为可以对并发和分布式系统的标准建模语言。
>
> 1997 年，UML 被对象管理组织（ISO）接纳为标准，并在此之后受该组织管理。2005 年，UML 被国际标准化组织接纳为一种标准，自此，该标准被定期修订以涵盖 UML 的最新版本。然而，在软件工程中，大多数从业者不使用 UML ，而是产生非正式的手绘图；不过，这些图例中仍往往包括 UML 的元素。

第四部分主要介绍一些软件工程中常用 UML 技术，符号图片主要来自 [Microsoft Visio](https://www.microsoft.com/en-us/microsoft-365/visio/flowchart-software) 。

### 4.1 <span id="4-1">用例图</span>

#### 介绍

#### 规范

#### 实例

### 4.2 <span id="4-2">类图</span>

#### 介绍

#### 规范

#### 实例

### 4.3 <span id="4-3">交互图</span>

#### 介绍

#### 规范

#### 实例

### 4.4 <span id="4-4">活动图</span>

#### 介绍

#### 规范

#### 实例

### 4.5 <span id="4-5">状态图</span>

#### 介绍

#### 规范

#### 实例